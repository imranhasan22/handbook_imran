# Content

- [BSON](#bson)
- [CRUD](#crud)
- [Query](#query)
- [Bulk Operations](#bulk-operations)
- [Relationships](#relationships)
- [Middleware](#middleware)

# BSON

BSON (Binary JSON) is a binary-encoded serialization of JSON-like documents.

BSON supports all JSON types and includes additional data types such as:

- **Date**: Stores date-time values.
- **ObjectId**: A unique identifier generated by MongoDB for each document.
- **Binary Data**: Stores binary data like images or files.
- **MinKey/MaxKey**: Special types used for comparing BSON elements.
- **Int32, Int64, Double**: Different numeric types for storing integer and floating-point numbers.

In MongoDB, data is stored in a document format, which uses BSON for storing these documents, and for representing data it just uses JSON-like structure.

**Example:**
When you insert a JSON-like document into MongoDB, it converts it into BSON format for internal storage.

**JSON:**

```json
{
  "name": "Wireless Mouse",
  "price": 25.99,
  "inStock": true,
  "manufacturedDate": "2024-01-01T00:00:00Z",
  "specifications": {
    "color": "black",
    "weight": 0.1
  }
}
```

**BSON:**

```bson
{
   "_id": ObjectId("64b8d2e3e8c3bc7fbb9d3e45"),
   "name": "Wireless Mouse",
   "price": 25.99,
   "inStock": true,
   "manufacturedDate": ISODate("2024-01-01T00:00:00Z"),
   "specifications": {
      "color": "black",
      "weight": Double(0.1)
   }
}
```

# CRUD

## Create

### `insertOne()`

```js
db.users.insertOne({
  name: "Alice",
  age: 28,
});
```

### `insertMany()`

```js
db.users.insertMany([
  {
    name: "Bob",
    age: 32,
  },
  {
    name: "Charlie",
    age: 25,
  },
]);
```

## Read

### `find()`

```js
db.users.find({ name: "Alice" });
```

### `findOne()`

```js
db.users.findOne({ name: "Alice" });
```

## Update

### `updateOne()`

```js
db.users.updateOne({ name: "Alice" }, { $set: { age: 29 } });
```

### `update()`

```
db.users.updateMany(
   { "age": { "$lt": 30 } },
   { "$set": { "status": "young" } }
);
```

## Delete

### `deleteOne()`

```js
db.users.deleteOne({ name: "Charlie" });
```

### `delete()`

```js
db.users.deleteMany({ age: { $lt: 30 } });
```

# Query

## Comparison

```js
db.users.find({ age: { $eq: 28 } });
```

- `$gt` - Greater Than
- `$gte` - Greater Than or Equal
- `$gt` - Less Than
- `$lte` - Less Than or Equal
- `$ne` - Not Equal
- `$in` - In
- `$nin` - Not In

## Logical

```js
db.users.find({
  $and: [{ age: { $gt: 25 } }, { age: { $lt: 30 } }],
});
```

- `$and` - Finds documents that match all conditions in the query.
- `$or` - Finds documents that match any condition in the query.
- `$not` - Negates a condition to find documents that do not match the specified query.
- `$nor` - Finds documents that do not match any of the specified conditions.

## Sorting

**Ascending:**

```js
db.users.find().sort({ age: 1 });
```

**Descending:**

```js
db.users.find().sort({ age: -1 });
```

## Pagination

- `limit()` - Limits the number of documents returned.
- `skip()` - Skips a specified number of documents.

## Combined

```js
db.users.find().sort({ age: 1 }).skip(5).limit(10);
```

# Bulk Operations

Bulk operations in MongoDB allow you to execute multiple write operations (inserts, updates, deletes) in a single request.

## Types of Bulk Operations

- **Ordered Bulk Operations**: Executes operations in the order they are defined. If an error occurs during one of the operations, MongoDB stops executing further operations.
- **Unordered Bulk Operations**: Executes operations in parallel without following a specific order. If an error occurs, MongoDB will continue executing the remaining operations.

## `bulkWrite()`

**Ordered:**

```js
db.users.bulkWrite([
  {
    insertOne: {
      document: {
        name: "Alice",
        age: 28,
      },
    },
  },
  {
    updateOne: {
      filter: { name: "Alice" },
      update: { $set: { age: 28 } },
    },
  },
  {
    deleteOne: {
      filter: { name: "Alice" },
    },
  },
]);
```

**Unordered:**

```js
db.users.bulkWrite(
  [
    {
      insertOne: {
        document: {
          name: "Alice",
          age: 28,
        },
      },
    },
    {
      updateOne: {
        filter: { name: "Alice" },
        update: { $set: { age: 28 } },
      },
    },
    {
      deleteOne: {
        filter: { name: "Alice" },
      },
    },
  ],
  { ordered: false }
);
```

# Relationships

## One-to-One

```js
const mongoose = require("mongoose");

// Define the User schema
const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  profile: { type: mongoose.Schema.Types.ObjectId, ref: "Profile" }, // Reference to Profile
});

// Define the Post schema
const postSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  user: { type: mongoose.Schema.Types.ObjectId, ref: "User" }, // Reference to User
});

// Create models
const User = mongoose.model("User", userSchema);
const Post = mongoose.model("Post", postSchema);
```

**Read:**

```js
const user = await User.findById(req.params.id).populate("profile");
```

## One-to-Many

```js
import mongoose from "mongoose";

// Define the User schema
const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
  },
  posts: [{ type: mongoose.Schema.Types.ObjectId, ref: "Post" }], // Array of Post IDs
});

// Define the Post schema
const postSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  user: { type: mongoose.Schema.Types.ObjectId, ref: "User" }, // Reference to User
});

// Create models
const User = mongoose.model("User", userSchema);
const Post = mongoose.model("Post", postSchema);
```

**Read:**

```js
const user = await User.findById(req.params.id).populate("posts");
```

## Many-to-Many

```js
// Define the Student schema
const studentSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  courses: [{ type: mongoose.Schema.Types.ObjectId, ref: "Course" }], // Array of Course IDs
});

// Define the Course schema
const courseSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
  },
  students: [{ type: mongoose.Schema.Types.ObjectId, ref: "Student" }], // Array of Student IDs
});

// Create models
const Student = mongoose.model("Student", studentSchema);
const Course = mongoose.model("Course", courseSchema);
```

**Create and Read:**

```js
// Enroll a Student in a Course
app.post("/enroll", async (req, res) => {
  const { studentId, courseId } = req.body;
  try {
    await Student.findByIdAndUpdate(studentId, {
      $addToSet: { courses: courseId },
    });
    await Course.findByIdAndUpdate(courseId, {
      $addToSet: { students: studentId },
    });
    res.status(200).json({ message: "Student enrolled successfully" });
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
});

// Get Student with Courses
app.get("/students/:id", async (req, res) => {
  try {
    const student = await Student.findById(req.params.id).populate("courses"); // Populate courses
    res.status(200).json(student);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});
```

# Middleware

## Types of Middleware in Mongoose

- **Document Middleware** (Pre/Post Hooks)
  - Executed before or after a document is saved, updated, validated, or deleted.
  - Common methods: save, validate, remove, updateOne, deleteOne.
- **Query Middleware** (Pre/Post Hooks)
  - Executed before or after executing a query.
  - Common methods: find, findOne, findOneAndUpdate, findOneAndDelete, etc.

## Document Middleware

```js
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String,
});

// Pre-save middleware to hash the password before saving
userSchema.pre("save", async function (next) {
  if (this.isModified("password")) {
    this.password = await hashPassword(this.password); // Assume `hashPassword` is a function that hashes passwords.
  }
  next();
});

// Post-save middleware to show message after saving
userSchema.post("save", function (doc, next) {
  console.log(`User ${doc.name} has been saved.`);
  next();
});
```

## Query Middleware

```js
userSchema.pre("find", function (next) {
  this.where({ isActive: true }); // Only find active users.
  next();
});

userSchema.post("find", function (docs, next) {
  console.log(`Found ${docs.length} users.`);
  next();
});
```
