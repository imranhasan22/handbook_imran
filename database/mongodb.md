# Content

- [BSON](#bson)
- [CRUD](#crud)
- [Query](#query)
- [Bulk Operations](#bulk-operations)
- [Aggregation Pipeline](#aggregation-pipeline)
- [Relationships](#relationships)
- [Middleware](#middleware)

# BSON

BSON (Binary JSON) is a binary-encoded serialization of JSON-like documents.

BSON supports all JSON types and includes additional data types such as:

- **Date**: Stores date-time values.
- **ObjectId**: A unique identifier generated by MongoDB for each document.
- **Binary Data**: Stores binary data like images or files.
- **MinKey/MaxKey**: Special types used for comparing BSON elements.
- **Int32, Int64, Double**: Different numeric types for storing integer and floating-point numbers.

In MongoDB, data is stored in a document format, which uses BSON for storing these documents, and for representing data it just uses JSON-like structure.

**Example:**
When you insert a JSON-like document into MongoDB, it converts it into BSON format for internal storage.

**JSON:**

```json
{
  "name": "Wireless Mouse",
  "price": 25.99,
  "inStock": true,
  "manufacturedDate": "2024-01-01T00:00:00Z",
  "specifications": {
    "color": "black",
    "weight": 0.1
  }
}
```

**BSON:**

```bson
{
   "_id": ObjectId("64b8d2e3e8c3bc7fbb9d3e45"),
   "name": "Wireless Mouse",
   "price": 25.99,
   "inStock": true,
   "manufacturedDate": ISODate("2024-01-01T00:00:00Z"),
   "specifications": {
      "color": "black",
      "weight": Double(0.1)
   }
}
```

# CRUD

## Create

### `insertOne()`

```js
db.users.insertOne({
  name: "Alice",
  age: 28,
});
```

### `insertMany()`

```js
db.users.insertMany([
  {
    name: "Bob",
    age: 32,
  },
  {
    name: "Charlie",
    age: 25,
  },
]);
```

## Read

### `find()`

```js
db.users.find({ name: "Alice" });
```

### `findOne()`

```js
db.users.findOne({ name: "Alice" });
```

## Update

### `updateOne()`

```js
db.users.updateOne({ name: "Alice" }, { $set: { age: 29 } });
```

### `update()`

```
db.users.updateMany(
   { "age": { "$lt": 30 } },
   { "$set": { "status": "young" } }
);
```

## Delete

### `deleteOne()`

```js
db.users.deleteOne({ name: "Charlie" });
```

### `delete()`

```js
db.users.deleteMany({ age: { $lt: 30 } });
```

# Query

## Comparison

```js
db.users.find({ age: { $eq: 28 } });
```

- `$gt` - Greater Than
- `$gte` - Greater Than or Equal
- `$gt` - Less Than
- `$lte` - Less Than or Equal
- `$ne` - Not Equal
- `$in` - In
- `$nin` - Not In

## Logical

```js
db.users.find({
  $and: [{ age: { $gt: 25 } }, { age: { $lt: 30 } }],
});
```

- `$and` - Finds documents that match all conditions in the query.
- `$or` - Finds documents that match any condition in the query.
- `$not` - Negates a condition to find documents that do not match the specified query.
- `$nor` - Finds documents that do not match any of the specified conditions.

## Sorting

**Ascending:**

```js
db.users.find().sort({ age: 1 });
```

**Descending:**

```js
db.users.find().sort({ age: -1 });
```

## Pagination

- `limit()` - Limits the number of documents returned.
- `skip()` - Skips a specified number of documents.

## Combined

```js
db.users.find().sort({ age: 1 }).skip(5).limit(10);
```

# Bulk Operations

Bulk operations in MongoDB allow you to execute multiple write operations (inserts, updates, deletes) in a single request.

## Types of Bulk Operations

- **Ordered Bulk Operations**: Executes operations in the order they are defined. If an error occurs during one of the operations, MongoDB stops executing further operations.
- **Unordered Bulk Operations**: Executes operations in parallel without following a specific order. If an error occurs, MongoDB will continue executing the remaining operations.

## `bulkWrite()`

**Ordered:**

```js
db.users.bulkWrite([
  {
    insertOne: {
      document: {
        name: "Alice",
        age: 28,
      },
    },
  },
  {
    updateOne: {
      filter: { name: "Alice" },
      update: { $set: { age: 28 } },
    },
  },
  {
    deleteOne: {
      filter: { name: "Alice" },
    },
  },
]);
```

**Unordered:**

```js
db.users.bulkWrite(
  [
    {
      insertOne: {
        document: {
          name: "Alice",
          age: 28,
        },
      },
    },
    {
      updateOne: {
        filter: { name: "Alice" },
        update: { $set: { age: 28 } },
      },
    },
    {
      deleteOne: {
        filter: { name: "Alice" },
      },
    },
  ],
  { ordered: false }
);
```
# Aggregation Pipeline
An aggregation pipeline is a sequence of stages that are applied to a collection of documents. Each stage processes the input documents and produces an output that serves as the input for the next stage. The result of the pipeline is the outcome after the last stage processes the data.
## Common Stages in Aggregation Pipelines
1. `$match`: Filters documents based on specified conditions, similar to the `find` query.
2. `$group`: Groups input documents by a specified identifier and applies accumulators (like sum, average).
3. `$project`: Reshapes documents by including or excluding fields, creating computed fields, or reformatting data.
4. `$sort`: Sorts documents by a specified field in ascending or descending order.
5. `$limit`: Limits the number of documents passing through the pipeline.
6. `$skip`: Skips a specified number of documents.
7. `$unwind`: Deconstructs an array field into multiple documents, one per array element.
8. `$lookup`: Performs a left outer join with another collection, allowing data from related documents to be combined.
9. `$addFields`: Adds new fields to the documents.

__Example Document:__
```json
[
  { "_id": 1, "product": "Laptop", "price": 1000, "quantity": 2, "date": "2024-01-10" },
  { "_id": 2, "product": "Phone", "price": 500, "quantity": 5, "date": "2024-01-11" },
  { "_id": 3, "product": "Tablet", "price": 300, "quantity": 7, "date": "2024-01-12" },
  { "_id": 4, "product": "Laptop", "price": 1100, "quantity": 1, "date": "2024-01-13" },
  { "_id": 5, "product": "Phone", "price": 600, "quantity": 3, "date": "2024-01-14" }
]
```
__Example:__
```js
db.sales.aggregate([
  // Stage 1: Calculate total revenue for each sale
  {
    $project: {
      product: 1,
      revenue: { $multiply: ["$price", "$quantity"] }
    }
  },
  // Stage 2: Group by product and sum the revenues
  {
    $group: {
      _id: "$product",
      totalRevenue: { $sum: "$revenue" }
    }
  },
  // Stage 3: Sort by total revenue in descending order
  {
    $sort: {
      totalRevenue: -1
    }
  }
]);
```
__Explaination:__
1. __Stage 1 - `$project`:__
  - This stage uses the $project operator to reshape each document, creating a new field called revenue by multiplying the price and quantity fields.
  - The output of this stage includes the product and the revenue calculated for each document.
  ```js
  [
    { "_id": 1, "product": "Laptop", "revenue": 2000 },
    { "_id": 2, "product": "Phone", "revenue": 2500 },
    { "_id": 3, "product": "Tablet", "revenue": 2100 },
    { "_id": 4, "product": "Laptop", "revenue": 1100 },
    { "_id": 5, "product": "Phone", "revenue": 1800 }
  ]
  ```
2. __Stage 2 - `$group`:__
  - Groups the documents by the `product` field (using `_id: "$product"`) and calculates the total revenue for each product using `$sum`.
  - The result of this stage aggregates the revenue for each product type.
  ```js
  [
    { "_id": "Phone", "totalRevenue": 4300 },
    { "_id": "Laptop", "totalRevenue": 3100 },
    { "_id": "Tablet", "totalRevenue": 2100 }
  ]
  ```
3. __Stage 3 - `$sort`:__
  - Sorts the results from the previous stage in descending order of `totalRevenue`.
  - This stage helps identify the product with the highest revenue.
  ```js
  [
    { "_id": "Phone", "totalRevenue": 4300 },
    { "_id": "Laptop", "totalRevenue": 3100 },
    { "_id": "Tablet", "totalRevenue": 2100 }
  ]
  ```
### `$match`
```js
db.sales.aggregate([
  {
    $match: { product: "Laptop" }
  }
]);
```
__Output:__
```json
[
  { "_id": 1, "product": "Laptop", "price": 1000, "quantity": 2, "date": "2024-01-10" },
  { "_id": 4, "product": "Laptop", "price": 1100, "quantity": 1, "date": "2024-01-13" },
]
```
### `$unwind`
__Example Document:__
```json
[
  { "_id": 1, "product": "Phone", "tags": ["electronics", "mobile"] },
  { "_id": 2, "product": "Laptop", "tags": ["electronics", "computer"] }
]
```
__Implementation__
```js
{
  $unwind: "$tags"
}
```
```json
[
  { "_id": 1, "product": "Phone", "tags": "electronics" },
  { "_id": 1, "product": "Phone", "tags": "mobile" },
  { "_id": 2, "product": "Laptop", "tags": "electronics" },
  { "_id": 2, "product": "Laptop", "tags": "computer" }
]
```
### `$lookup`
```js
db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customerId",
      foreignField: "_id",
      as: "customerDetails"
    }
  }
]);
```
# Relationships

## One-to-One

```js
const mongoose = require("mongoose");

// Define the User schema
const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
  },
  profile: { type: mongoose.Schema.Types.ObjectId, ref: "Profile" }, // Reference to Profile
});

// Define the Post schema
const postSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  user: { type: mongoose.Schema.Types.ObjectId, ref: "User" }, // Reference to User
});

// Create models
const User = mongoose.model("User", userSchema);
const Post = mongoose.model("Post", postSchema);
```

**Read:**

```js
const user = await User.findById(req.params.id).populate("profile");
```

## One-to-Many

```js
import mongoose from "mongoose";

// Define the User schema
const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
  },
  posts: [{ type: mongoose.Schema.Types.ObjectId, ref: "Post" }], // Array of Post IDs
});

// Define the Post schema
const postSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
  },
  content: {
    type: String,
    required: true,
  },
  user: { type: mongoose.Schema.Types.ObjectId, ref: "User" }, // Reference to User
});

// Create models
const User = mongoose.model("User", userSchema);
const Post = mongoose.model("Post", postSchema);
```

**Read:**

```js
const user = await User.findById(req.params.id).populate("posts");
```

## Many-to-Many

```js
// Define the Student schema
const studentSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  courses: [{ type: mongoose.Schema.Types.ObjectId, ref: "Course" }], // Array of Course IDs
});

// Define the Course schema
const courseSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
  },
  students: [{ type: mongoose.Schema.Types.ObjectId, ref: "Student" }], // Array of Student IDs
});

// Create models
const Student = mongoose.model("Student", studentSchema);
const Course = mongoose.model("Course", courseSchema);
```

**Create and Read:**

```js
// Enroll a Student in a Course
app.post("/enroll", async (req, res) => {
  const { studentId, courseId } = req.body;
  try {
    await Student.findByIdAndUpdate(studentId, {
      $addToSet: { courses: courseId },
    });
    await Course.findByIdAndUpdate(courseId, {
      $addToSet: { students: studentId },
    });
    res.status(200).json({ message: "Student enrolled successfully" });
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
});

// Get Student with Courses
app.get("/students/:id", async (req, res) => {
  try {
    const student = await Student.findById(req.params.id).populate("courses"); // Populate courses
    res.status(200).json(student);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});
```

# Middleware

## Types of Middleware in Mongoose

- **Document Middleware** (Pre/Post Hooks)
  - Executed before or after a document is saved, updated, validated, or deleted.
  - Common methods: save, validate, remove, updateOne, deleteOne.
- **Query Middleware** (Pre/Post Hooks)
  - Executed before or after executing a query.
  - Common methods: find, findOne, findOneAndUpdate, findOneAndDelete, etc.

## Document Middleware

```js
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String,
});

// Pre-save middleware to hash the password before saving
userSchema.pre("save", async function (next) {
  if (this.isModified("password")) {
    this.password = await hashPassword(this.password); // Assume `hashPassword` is a function that hashes passwords.
  }
  next();
});

// Post-save middleware to show message after saving
userSchema.post("save", function (doc, next) {
  console.log(`User ${doc.name} has been saved.`);
  next();
});
```

## Query Middleware

```js
userSchema.pre("find", function (next) {
  this.where({ isActive: true }); // Only find active users.
  next();
});

userSchema.post("find", function (docs, next) {
  console.log(`Found ${docs.length} users.`);
  next();
});
```
